import {
  Abstraction,
  Relationship,
  ProjectAnalysis,
  ChapterOutput,
  TutorialFile,
  CombineTutorialOptions,
  ChapterLinkInfo, // Re-using this from write-chapters context if needed for chapter info
} from '../types';

// Helper to sanitize text for Mermaid diagram
// Exported for testing purposes
export function sanitizeForMermaid(text: string): string {
  // Replace characters that might break Mermaid syntax or cause issues.
  // Quotes are particularly problematic in node labels/edge text.
  let sanitized = text.replace(/"/g, '#quot;'); // Replace quotes
  sanitized = sanitized.replace(/\(/g, '#lpar;'); // Replace (
  sanitized = sanitized.replace(/\)/g, '#rpar;'); // Replace )
  // Add more replacements if needed, e.g., for newlines if they are not desired in labels
  // sanitized = sanitized.replace(/\n/g, ' '); // Example: replace newlines with space
  return sanitized;
}

const ATTRIBUTION_TEXT = "\n\n---\n*Generated by AI Codebase Knowledge Builder. Review and adapt as needed.*";

export function combineTutorial(
  projectName: string,
  projectAnalysis: ProjectAnalysis,
  abstractions: Abstraction[],
  chapterOrder: number[], // Array of abstraction indices
  chaptersOutput: ChapterOutput[],
  options: CombineTutorialOptions = {}
): TutorialFile[] {
  const tutorialFiles: TutorialFile[] = [];

  // --- 1. Generate Mermaid Diagram ---
  let mermaidDiagram = 'flowchart TD\n';
  // Add nodes
  abstractions.forEach((abs, index) => {
    // Ensure a unique ID for each node, e.g., A0, A1, etc.
    // Sanitize name for display within the node
    mermaidDiagram += `    A${index}["${sanitizeForMermaid(abs.name)}"]\n`;
  });
  // Add edges
  if (projectAnalysis.relationships) {
    projectAnalysis.relationships.forEach(rel => {
      // Ensure from/to indices are valid before creating edge
      if (rel.from >= 0 && rel.from < abstractions.length && rel.to >= 0 && rel.to < abstractions.length) {
        mermaidDiagram += `    A${rel.from} -- "${sanitizeForMermaid(rel.label)}" --> A${rel.to}\n`;
      } else {
        console.warn(`Skipping invalid relationship in Mermaid diagram: from ${rel.from} to ${rel.to}`);
      }
    });
  }

  // --- 2. Prepare index.md Content ---
  let indexMdContent = `# Tutorial: ${projectName}\n\n`;
  indexMdContent += `${projectAnalysis.summary || 'Welcome to the tutorial!'}\n\n`;

  if (options.repoUrl) {
    indexMdContent += `**Source Repository:** [${options.repoUrl}](${options.repoUrl})\n\n`;
  }

  indexMdContent += '## Project Overview Diagram\n\n';
  indexMdContent += '```mermaid\n';
  indexMdContent += mermaidDiagram;
  indexMdContent += '```\n\n';

  indexMdContent += '## Chapters\n\n';

  // Create a map for quick lookup of ChapterOutput by abstractionIndex
  const chapterOutputMap = new Map<number, ChapterOutput>();
  chaptersOutput.forEach(co => chapterOutputMap.set(co.abstractionIndex, co));

  chapterOrder.forEach((absIndex, i) => {
    const chapterNum = i + 1;
    const chapterInfo = chapterOutputMap.get(absIndex);
    
    if (chapterInfo) {
      indexMdContent += `${chapterNum}. [${chapterInfo.title}](${chapterInfo.filename})\n`;
    } else {
      // Fallback if a chapter output is somehow missing (should not happen in normal flow)
      const abs = abstractions[absIndex];
      const title = abs ? abs.name : `Chapter ${chapterNum}`;
      // Attempt to find a filename based on chapter number if no direct output exists
      // This is a failsafe, ideally chapterInfo should always be found.
      const fallbackFilename = `chapter_${String(chapterNum).padStart(2,'0')}.md`;
      console.warn(`Could not find ChapterOutput for abstraction index ${absIndex}. Using fallback title and filename.`);
      indexMdContent += `${chapterNum}. [${title}](${fallbackFilename})\n`;
    }
  });
  indexMdContent += '\n';
  indexMdContent += ATTRIBUTION_TEXT;

  tutorialFiles.push({
    filename: 'index.md',
    content: indexMdContent,
  });

  // --- 3. Prepare Individual Chapter Files ---
  chaptersOutput.forEach(chapter => {
    // Ensure attribution is present. WriteChapters might have already added some form.
    // This makes sure a consistent one is at the very end.
    let chapterContentWithAttribution = chapter.content;
    if (!chapterContentWithAttribution.includes(ATTRIBUTION_TEXT.trim())) { // Avoid double attribution
        chapterContentWithAttribution += ATTRIBUTION_TEXT;
    }

    tutorialFiles.push({
      filename: chapter.filename,
      content: chapterContentWithAttribution,
    });
  });
  
  console.log(`Combined tutorial into ${tutorialFiles.length} files (index + chapters).`);
  return tutorialFiles;
}
