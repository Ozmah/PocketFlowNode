import { FetchedFile } from "./utils/crawl_github_files"; // Re-export FetchedFile

// Define a placeholder for Abstraction and Relationship types for now
// These will be fleshed out in later steps.
export interface AbstractionBase {
	id: string; // Or number, depending on how you want to identify them
	name: string;
	filePath?: string; // Path to the file where this abstraction is defined
	// Add other common properties for abstractions if any
}

// Example: A more specific abstraction type, can be part of a union type for `abstractions`
export interface CodeAbstraction extends AbstractionBase {
	type: "function" | "class" | "interface" | "variable" | "module";
	// Add code-specific properties, e.g., parameters, return type for functions
}

export interface Relationship {
	sourceId: string; // ID of the source abstraction
	targetId: string; // ID of the target abstraction
	type: "uses" | "calls" | "imports" | "exports" | "contains" | "relatedTo"; // Example relationship types
	// Add other properties like description or strength if needed
}

/**
 * @interface SharedData
 * @description Defines the complete data structure for the AI-powered codebase tutorial generation workflow.
 * This interface serves as a central data container that flows through all stages of the tutorial generation process,
 * from initial repository analysis to final tutorial output generation.
 *
 * @property {string} repoUrl - The GitHub repository URL to analyze and generate tutorial from (mandatory).
 * @property {string} [localDir] - Optional local directory path for processing files locally instead of fetching from GitHub.
 * @property {string} [projectName] - Human-readable name for the project being analyzed.
 * @property {string} [githubToken] - GitHub Personal Access Token for accessing private repositories or increasing API rate limits.
 * @property {string[]} [includePatterns] - Array of glob patterns specifying which files to include in the analysis.
 * @property {string[]} [excludePatterns] - Array of glob patterns specifying which files to exclude from analysis.
 * @property {number} [maxFileSize] - Maximum file size in bytes for files to be processed.
 * @property {string} [language] - Target language for tutorial content generation.
 * @property {boolean} [useCache] - Whether to enable caching for LLM API calls.
 * @property {number} [maxAbstractions] - Maximum number of key abstractions to identify in the codebase.
 * @property {string} [llmProvider] - The LLM provider to use for content generation.
 * @property {string} [llmModelName] - Specific model name within the chosen LLM provider.
 * @property {FetchedFile[]} [files] - Array of files fetched from the repository during the crawling phase.
 * @property {AbstractionBase[]} [abstractions] - Array of key abstractions identified in the codebase.
 * @property {Relationship[]} [relationships] - Array of relationships between identified abstractions.
 * @property {string[]} [chapterOrder] - Ordered array of abstraction IDs or names defining tutorial chapter sequence.
 * @property {Object[]} [chapters] - Array of generated tutorial chapters with their content.
 * @property {string} [finalOutputDir] - File system path where tutorial files will be saved.
 * @property {string} [finalTutorialContent] - Complete tutorial content as a single consolidated string.
 */
export interface SharedData {
	/**
	 * The GitHub repository URL to analyze and generate tutorial from.
	 * This is the primary input and is mandatory for the workflow to function.
	 * @example "https://github.com/Ozmah/PocketFlowNode"
	 */
	repoUrl: string;

	/**
	 * Optional local directory path for processing files locally instead of fetching from GitHub.
	 * Currently not implemented yet.
	 * @example "/path/to/local/project"
	 */
	localDir?: string;

	/**
	 * Human-readable name for the project being analyzed.
	 * Used in tutorial titles and output file names. If not provided, will be derived from the repository URL.
	 * @example "My Awesome Project"
	 */
	projectName?: string;

	/**
	 * GitHub Personal Access Token for accessing private repositories or increasing API rate limits.
	 * Optional for public repositories.
	 * @example "ghp_1234567890abcdef..."
	 */
	githubToken?: string;
	includePatterns?: string[];
	excludePatterns?: string[];
	maxFileSize?: number;
	language?: string;
	useCache?: boolean; // For LLM calls and potentially other caching
	maxAbstractions?: number;
	llmProvider?: string;
	llmModelName?: string;
	//llmOptions pending

	// Data generated by workflow steps
	files?: FetchedFile[]; // Output of fetchRepo (crawlGitHubFiles)
	abstractions?: AbstractionBase[]; // Output of identifyAbstractions - use a more specific type or union if needed
	relationships?: Relationship[]; // Output of analyzeRelationships

	// For tutorial generation
	chapterOrder?: string[]; // Array of abstraction IDs or names, defining the order
	chapters?: { id: string; title: string; content: string }[]; // Markdown content of chapters, id links to abstraction

	// Final output details
	finalOutputDir?: string; // Path for saving files, or could be a buffer for a ZIP
	finalTutorialContent?: string; // Could be one large markdown file, or structure for multiple files
}

// --- Interfaces for identifyAbstractions ---
// FetchedFile is already defined in ./utils/crawl_github_files.ts and imported where needed.
// We'll ensure it's compatible or re-export/re-define if necessary for clarity.

export interface Abstraction {
	// id will be generated after identifying abstractions, perhaps based on hash or order.
	// For now, the core fields returned by LLM and validated are:
	name: string;
	description: string;
	fileIndices: number[]; // Array of valid integer indices referencing the input filesData array
	// Optional: We can add a 'files?: string[]' field later if we want to store resolved paths,
	// but the LLM is asked for indices.
}

export interface IdentifyAbstractionsOptions {
	language?: string; // For prompt instructions
	useCache?: boolean; // For LLM calls
	maxAbstractions?: number; // To limit the number of abstractions identified
	/**
	 * @property {string} [providerName] - The name of the LLM provider to use.
	 * Defaults to 'gemini' if not specified (this default is handled by `callLlm`).
	 */
	providerName?: string;
	/**
	 * @property {string} [llmModelName] - The specific model name for the selected LLM provider.
	 * If not provided, the default model for the provider will be used.
	 */
	llmModelName?: string;
}

// --- Interfaces for analyzeRelationships ---
// FetchedFile and Abstraction are assumed to be defined above or imported.

export interface Relationship {
	// We will use integer indices for 'from' and 'to' that correspond to the
	// index in the 'abstractions' array passed to analyzeRelationships.
	from: number; // Index of the source abstraction in the input array
	to: number; // Index of the target abstraction in the input array
	label: string; // Description of the relationship
}

export interface ProjectAnalysis {
	summary: string;
	relationships: Relationship[];
}

export interface AnalyzeRelationshipsOptions {
	language?: string; // For prompt instructions (summary, labels)
	useCache?: boolean; // For LLM calls
	/**
	 * @property {string} [providerName] - The name of the LLM provider to use.
	 * Defaults to 'gemini' if not specified (this default is handled by `callLlm`).
	 */
	providerName?: string;
	/**
	 * @property {string} [llmModelName] - The specific model name for the selected LLM provider.
	 * If not provided, the default model for the provider will be used.
	 */
	llmModelName?: string;
}

// --- Interfaces for orderChapters ---
// Abstraction, Relationship, ProjectAnalysis are assumed to be defined above or imported.

export interface OrderChaptersOptions {
	language?: string; // For prompt context notes, as LLM deals with potentially translated names/summaries
	useCache?: boolean; // For LLM calls
	/**
	 * @property {string} [providerName] - The name of the LLM provider to use.
	 * Defaults to 'gemini' if not specified (this default is handled by `callLlm`).
	 */
	providerName?: string;
	/**
	 * @property {string} [llmModelName] - The specific model name for the selected LLM provider.
	 * If not provided, the default model for the provider will be used.
	 */
	llmModelName?: string;
}

// --- Interfaces for writeChapters ---
// FetchedFile and Abstraction are assumed to be defined above or imported.

export interface ChapterOutput {
	chapterNumber: number;
	abstractionIndex: number; // The original index from the input 'abstractions' array
	title: string; // The name of the abstraction, which serves as the chapter title
	content: string; // Markdown content of the chapter
	filename: string; // Sanitized filename for this chapter
}

export interface WriteChaptersOptions {
	language?: string;
	useCache?: boolean;
	/**
	 * @property {string} [providerName] - The name of the LLM provider to use (e.g., 'gemini', 'chatgpt', 'claude').
	 * Defaults to 'gemini' if not specified (this default is handled by `callLlm`).
	 */
	providerName?: string;
	/**
	 * @property {string} [llmModelName] - The specific model name for the selected LLM provider.
	 * If not provided, the default model for the provider will be used.
	 */
	llmModelName?: string;
}

// Helper for chapter linking information
export interface ChapterLinkInfo {
	num: number; // Chapter number (1-based)
	name: string; // Abstraction name (potential chapter title)
	filename: string; // Sanitized filename
}

// --- Interfaces for combineTutorial ---
// Abstraction, Relationship, ProjectAnalysis, ChapterOutput are assumed to be defined above or imported.

export interface TutorialFile {
	filename: string;
	content: string;
}

export interface CombineTutorialOptions {
	repoUrl?: string; // For linking in index.md
	// language?: string; // If attribution or other fixed text needs translation (not strictly required by prompt)
}
