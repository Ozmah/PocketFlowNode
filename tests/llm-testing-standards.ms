# PocketFlow Node.js Testing Standards - Comprehensive LLM Reference Guide

## üìã Overview

This document serves as the definitive, comprehensive reference for writing and evaluating Jest tests in the PocketFlow Node.js project. It consolidates testing standards, real-world debugging experiences, and proven patterns for Node.js + Express + TypeScript + Jest testing, with special emphasis on LLM Provider testing patterns.

**Target Audience:** LLMs and developers writing tests for PocketFlow Node  
**Scope:** Unit and integration tests using Jest with TypeScript  
**Compliance:** ALL tests must adhere to these standards  
**Status:** Updated with real-world debugging insights and proven solutions

---

## üéØ Critical Standards Checklist

### ‚úÖ MUST HAVE (Non-negotiable)

-   [ ] Single mock clearing strategy (`jest.clearAllMocks()` ONLY)
-   [ ] Proper TypeScript mock typing
-   [ ] Complete environment variable management
-   [ ] Console output suppression in tests
-   [ ] ESM compatibility (`__esModule: true`)
-   [ ] Defensive beforeEach setup
-   [ ] Comprehensive error scenario coverage
-   [ ] Correct Jest API usage (no asymmetric matchers with `toThrow()`)
-   [ ] Proper mock hoisting patterns

### ‚ö†Ô∏è MUST NOT HAVE (Anti-patterns)

-   [ ] Mixed mock clearing (`mockReset()` + `jest.clearAllMocks()`)
-   [ ] Unhandled environment pollution
-   [ ] Console noise in test output
-   [ ] Incomplete mock configurations
-   [ ] Missing TypeScript types for mocks
-   [ ] `expect.stringContaining()` with `rejects.toThrow()` or `toThrow()`
-   [ ] `jest.resetModules()` (resets module cache, causes re-imports)
-   [ ] Mock hoisting violations (using variables before declaration)

---

## üö® Mock Hoisting: Critical Understanding

### The Problem

JavaScript hoisting and Jest's mock system can create initialization order issues that cause tests to fail with cryptic errors like:

```
ReferenceError: Cannot access 'mockVariable' before initialization
```

### ‚úÖ CORRECT Mock Hoisting Pattern

**PROVEN SUCCESSFUL PATTERN** (From `chatgpt-provider.test.ts`):

```typescript
// ‚úÖ CORRECT: Define mock structure BEFORE jest.mock()
const mockCreateChatCompletion = jest.fn();
const mockProviderInstance = {
	chat: {
		completions: {
			create: mockCreateChatCompletion,
		},
	},
};

// ‚úÖ CORRECT: Define everything inside jest.mock() callback
jest.mock("external-module", () => {
	return jest.fn().mockImplementation(() => mockProviderInstance);
});

// ‚úÖ CORRECT: Get typed reference AFTER the mock
const MockedConstructor = ExternalModule as jest.MockedClass<typeof ExternalModule>;
```

### ‚ùå INCORRECT Mock Hoisting Patterns

```typescript
// ‚ùå BAD: Trying to use variable in jest.mock() before it's fully initialized
const mockConstructor = jest.fn()...
jest.mock("module", () => mockConstructor); // ERROR: hoisting issue

// ‚ùå BAD: Complex mock definition that references uninitialized variables
jest.mock("module", () => mockComplexVariable); // If mockComplexVariable uses other mocks

// ‚ùå BAD: Trying to add properties to jest.fn() in global scope
const mockFn = jest.fn();
mockFn.APIError = class APIError extends Error {}; // Can cause hoisting issues
```

### üîß LLM Provider Mock Patterns (PROVEN)

Based on successful implementations, here are the exact patterns that work:

#### For OpenAI (ChatGPT) - REFERENCE PATTERN

```typescript
// ‚úÖ PROVEN SUCCESSFUL - Use this as template
const mockCreateChatCompletion = jest.fn();
const mockOpenAIInstance = {
	chat: {
		completions: {
			create: mockCreateChatCompletion,
		},
	},
};

jest.mock("openai", () => {
	return jest.fn().mockImplementation(() => mockOpenAIInstance);
});

// Get typed reference after mock
const MockedOpenAIConstructor = OpenAI as jest.MockedClass<typeof OpenAI>;
```

#### For Anthropic (Claude) - ADAPTED PATTERN

```typescript
// ‚úÖ CORRECT: Following the proven OpenAI pattern
const mockMessagesCreate = jest.fn();
const mockAnthropicInstance = {
	messages: {
		create: mockMessagesCreate,
	},
};

jest.mock("@anthropic-ai/sdk", () => {
	// Define everything inside the callback to avoid hoisting issues
	const constructorMock = jest.fn().mockImplementation(() => mockAnthropicInstance);

	// @ts-ignore - Necessary for adding APIError class
	constructorMock.APIError = class APIError extends Error {
		status?: number;
		headers?: Record<string, string>;
		constructor(message: string, status?: number, headers?: Record<string, string>) {
			super(message);
			this.name = "APIError";
			this.status = status;
			this.headers = headers;
		}
	};
	return constructorMock;
});

const MockedAnthropicConstructor = Anthropic as jest.MockedClass<typeof Anthropic>;
```

#### For Google AI (Gemini) - ADAPTED PATTERN

```typescript
// ‚úÖ CORRECT: Following the proven pattern
const mockGenerateContent = jest.fn();
const mockGetGenerativeModel = jest.fn(() => ({
	generateContent: mockGenerateContent,
}));

jest.mock("@google/generative-ai", () => ({
	GoogleGenerativeAI: jest.fn(() => ({
		getGenerativeModel: mockGetGenerativeModel,
	})),
	HarmCategory: {
		HARM_CATEGORY_HARASSMENT: "HARM_CATEGORY_HARASSMENT",
		// ... other categories
	},
	HarmBlockThreshold: {
		BLOCK_NONE: "BLOCK_NONE",
	},
}));

const MockedGoogleGenerativeAIConstructor = GoogleGenerativeAI as jest.MockedClass<typeof GoogleGenerativeAI>;
```

---

## üîß 1. Mock Configuration Standards

### ‚úÖ CORRECT Mock Setup

```typescript
// External module mocking following proven patterns
const mockApiMethod = jest.fn();
const mockProviderInstance = {
	api: {
		method: mockApiMethod,
	},
};

jest.mock("external-module", () => {
	return jest.fn().mockImplementation(() => mockProviderInstance);
});

// Internal module mocking with ESM compatibility
jest.mock("../../src/utils/module", () => ({
	functionA: jest.fn(),
	functionB: jest.fn(),
	functionC: jest.fn(),
	__esModule: true, // üéØ CRITICAL for ESM compatibility
}));
```

### ‚ùå INCORRECT Mock Setup

```typescript
// ‚ùå BAD: Hoisting violation
const mockVariable = complexInitialization();
jest.mock("module", () => mockVariable); // Can cause hoisting errors

// ‚ùå BAD: Missing ESM compatibility
jest.mock("../../src/utils/module", () => ({
	functionA: jest.fn(),
	functionB: jest.fn(),
	// Missing __esModule: true
}));

// ‚ùå BAD: Partial mock that allows real code execution
jest.mock("external-module", () => ({
	...jest.requireActual("external-module"),
	specificFunction: jest.fn(),
}));
```

---

## üßπ 2. Mock Lifecycle Management

### ‚úÖ CORRECT Cleanup Pattern

```typescript
describe("ComponentName", () => {
	beforeEach(() => {
		// ‚úÖ SINGLE source of truth for mock clearing
		jest.clearAllMocks();

		// ‚úÖ Set up default mock implementations AFTER clearing
		(mockFunction as jest.Mock).mockReturnValue(defaultValue);
		(mockAsyncFunction as jest.Mock).mockResolvedValue(defaultAsyncValue);
	});
});
```

### ‚ùå INCORRECT Cleanup Patterns

```typescript
beforeEach(() => {
	// ‚ùå BAD: jest.resetModules() is a critical anti-pattern
	jest.resetModules(); // NEVER USE THIS

	// ‚ùå BAD: Redundant and potentially conflicting
	mockSpecificFunction.mockReset();
	mockAnotherFunction.mockClear();
	jest.clearAllMocks(); // This makes the above redundant

	// ‚ùå BAD: Manual cleanup of individual mocks when using clearAllMocks
	(utils.function as jest.Mock).mockReset();
});
```

---

## üåç 3. Environment Variable Management

### ‚úÖ CORRECT Environment Handling

```typescript
describe("ProviderClass", () => {
	const OLD_ENV = process.env;

	afterAll(() => {
		process.env = OLD_ENV; // ‚úÖ Always restore
	});

	beforeEach(() => {
		process.env = { ...OLD_ENV }; // ‚úÖ Clean slate per test

		// Set required env vars for test
		process.env.REQUIRED_API_KEY = MOCK_API_KEY;
	});

	test("should handle missing environment variable", () => {
		delete process.env.REQUIRED_API_KEY; // ‚úÖ Safe deletion
		expect(() => new ProviderClass()).toThrow("REQUIRED_API_KEY environment variable is not set.");
	});
});
```

### ‚ùå INCORRECT Environment Handling

```typescript
// ‚ùå BAD: No backup of original environment
beforeEach(() => {
	process.env.API_KEY = "test-key";
});

// ‚ùå BAD: Direct mutation without restoration
test("missing env var test", () => {
	process.env.API_KEY = undefined; // Dangerous
	// ... rest of test
});

// ‚ùå BAD: No cleanup
afterAll(() => {
	// Missing environment restoration
});
```

---

## ü§´ 4. Console Output Management

### ‚úÖ CORRECT Console Suppression

```typescript
describe("ClassWithLogging", () => {
	let consoleWarnSpy: jest.SpyInstance;
	let consoleLogSpy: jest.SpyInstance;
	let consoleErrorSpy: jest.SpyInstance;

	beforeAll(() => {
		// ‚úÖ Suppress noise while preserving testability
		consoleWarnSpy = jest.spyOn(console, "warn").mockImplementation(() => {});
		consoleLogSpy = jest.spyOn(console, "log").mockImplementation(() => {});
		consoleErrorSpy = jest.spyOn(console, "error").mockImplementation(() => {});
	});

	afterAll(() => {
		// ‚úÖ Always restore console methods
		consoleWarnSpy.mockRestore();
		consoleLogSpy.mockRestore();
		consoleErrorSpy.mockRestore();
	});

	test("should log expected messages", async () => {
		await someFunction();

		// ‚úÖ Verify console calls even when suppressed
		expect(consoleLogSpy).toHaveBeenCalledWith(expect.stringContaining("Expected log message"));
	});
});
```

### ‚ùå INCORRECT Console Management

```typescript
// ‚ùå BAD: No console suppression (noisy tests)
describe("ClassWithLogging", () => {
	// No console management
});

// ‚ùå BAD: Incomplete suppression
beforeAll(() => {
	jest.spyOn(console, "log").mockImplementation(() => {}); // Only log, missing warn/error
});

// ‚ùå BAD: No restoration
afterAll(() => {
	// Missing mockRestore() calls
});
```

---

## üìù 5. TypeScript Mock Typing Standards

### ‚úÖ CORRECT TypeScript Mock Typing

```typescript
// ‚úÖ Proper constructor mock typing - PROVEN PATTERN
const MockedConstructor = ExternalClass as jest.MockedClass<typeof ExternalClass>;

// ‚úÖ Proper function mock typing with utility imports
import * as utils from "../../src/utils/module";
(utils.functionName as jest.Mock).mockReturnValue(value);

// ‚úÖ Alternative: Using jest.mocked() (Jest 27+)
import { jest } from "@jest/globals";
const mockedFunction = jest.mocked(utils.functionName);
mockedFunction.mockReturnValue(value);

// ‚úÖ Type-safe mock verification
expect(MockedConstructor).toHaveBeenCalledWith(expectedArgs);
```

### ‚ùå INCORRECT TypeScript Mock Typing

```typescript
// ‚ùå BAD: Using 'any' to bypass typing
(utils.functionName as any).mockReturnValue(value);

// ‚ùå BAD: No typing for constructor mocks
const mockedConstructor = ExternalClass; // Missing jest.MockedClass

// ‚ùå BAD: Incorrect assertion casting
expect(ExternalClass as any).toHaveBeenCalled();
```

---

## üß™ 6. Test Structure Standards

### ‚úÖ CORRECT Test Organization (PROVEN PATTERN)

Based on successful LLM Provider tests:

```typescript
describe("ProviderName", () => {
	// ‚úÖ Constants defined at top level
	const OLD_ENV = process.env;
	const MOCK_API_KEY = "test-api-key";
	const MOCK_PROMPT = "Test prompt";
	const MOCK_RESPONSE_TEXT = "Test response";
	const MOCK_PROMPT_HASH = "testhash123";

	// ‚úÖ Console suppression (always include for LLM providers)
	let consoleWarnSpy: jest.SpyInstance;
	let consoleLogSpy: jest.SpyInstance;
	let consoleErrorSpy: jest.SpyInstance;

	beforeAll(() => {
		consoleWarnSpy = jest.spyOn(console, "warn").mockImplementation(() => {});
		consoleLogSpy = jest.spyOn(console, "log").mockImplementation(() => {});
		consoleErrorSpy = jest.spyOn(console, "error").mockImplementation(() => {});
	});

	afterAll(() => {
		consoleWarnSpy.mockRestore();
		consoleLogSpy.mockRestore();
		consoleErrorSpy.mockRestore();
		process.env = OLD_ENV;
	});

	beforeEach(() => {
		// ‚úÖ Environment reset and mock clearing ONLY
		process.env = { ...OLD_ENV };
		jest.clearAllMocks();

		// ‚úÖ Set up default mock implementations
		(llmUtils.hashPrompt as jest.Mock).mockReturnValue(MOCK_PROMPT_HASH);
		(llmUtils.loadCache as jest.Mock).mockResolvedValue({});
		mockApiMethod.mockResolvedValue(mockSuccessResponse);
	});

	describe("Constructor", () => {
		test("should throw an error if API_KEY is not set", () => {
			delete process.env.API_KEY;
			expect(() => new ProviderClass()).toThrow("API_KEY environment variable is not set.");
		});

		test("should not throw an error if API_KEY is set", () => {
			process.env.API_KEY = MOCK_API_KEY;
			expect(() => new ProviderClass()).not.toThrow();
		});
	});

	describe("generate method", () => {
		beforeEach(() => {
			process.env.API_KEY = MOCK_API_KEY;
		});

		// ‚úÖ Cache tests following proven pattern
		test("should successfully generate text with cache miss", async () => {
			const provider = new ProviderClass();
			const options: LlmOptions = { useCache: true };
			const response = await provider.generate(MOCK_PROMPT, options);

			// ‚úÖ CONSISTENT ORDER: Input validation
			expect(llmUtils.hashPrompt).toHaveBeenCalledWith(MOCK_PROMPT);

			// ‚úÖ Cache operations
			expect(llmUtils.loadCache).toHaveBeenCalledTimes(2);

			// ‚úÖ API calls
			expect(MockedConstructor).toHaveBeenCalledWith({ apiKey: MOCK_API_KEY });
			expect(mockApiMethod).toHaveBeenCalledWith(expectedCallStructure);

			// ‚úÖ Side effects
			expect(llmUtils.saveCache).toHaveBeenCalledWith({ [MOCK_PROMPT_HASH]: MOCK_RESPONSE_TEXT });
			expect(llmUtils.logInteraction).toHaveBeenCalledWith(MOCK_PROMPT, MOCK_RESPONSE_TEXT);

			// ‚úÖ Return value
			expect(response).toBe(MOCK_RESPONSE_TEXT);

			// ‚úÖ Console verification (if applicable)
			expect(consoleLogSpy).toHaveBeenCalledWith(expect.stringContaining("Cache MISS"));
		});

		// ... other tests following same pattern
	});
});
```

---

## üéØ 7. Assertion Standards

### ‚úÖ CORRECT Assertions (PROVEN ORDER)

Based on successful LLM Provider tests, use this consistent order:

```typescript
test("should perform complete operation", async () => {
	const result = await provider.generate(MOCK_PROMPT, options);

	// 1. ‚úÖ Input validation
	expect(llmUtils.hashPrompt).toHaveBeenCalledWith(MOCK_PROMPT);

	// 2. ‚úÖ Cache operations
	expect(llmUtils.loadCache).toHaveBeenCalledTimes(2);

	// 3. ‚úÖ API calls
	expect(MockedConstructor).toHaveBeenCalledWith(expectedArgs);
	expect(mockApiMethod).toHaveBeenCalledWith(expectedCallStructure);

	// 4. ‚úÖ Side effects
	expect(llmUtils.saveCache).toHaveBeenCalledWith(expectedData);
	expect(llmUtils.logInteraction).toHaveBeenCalledWith(MOCK_PROMPT, MOCK_RESPONSE_TEXT);

	// 5. ‚úÖ Return value
	expect(result).toBe(EXPECTED_RESULT);

	// 6. ‚úÖ Console verification (if applicable)
	expect(consoleLogSpy).toHaveBeenCalledWith(expect.stringContaining("Expected message"));

	// 7. ‚úÖ Negative cases
	expect(mockUnrelatedFunction).not.toHaveBeenCalled();
});
```

### ‚ùå INCORRECT Assertions

```typescript
test("incomplete test", async () => {
	// ‚ùå BAD: Only testing return value
	const result = await provider.generate(MOCK_PROMPT);
	expect(result).toBe(EXPECTED_RESULT);

	// Missing verification of:
	// - Function calls
	// - Side effects
	// - Negative cases
});
```

---

## üéØ 8. Jest API Limitations and Error Testing Patterns

### ‚úÖ CORRECT Error Testing Patterns

```typescript
describe("Error Testing Best Practices", () => {
	test("should handle API errors with regex patterns", async () => {
		const errorMessage = "API Error";
		mockFunction.mockRejectedValue(new Error(errorMessage));

		// ‚úÖ CORRECT: Use regex for flexible matching
		await expect(provider.method()).rejects.toThrow(/API Error.*failed.*status/);

		// ‚úÖ CORRECT: Use exact string if known
		await expect(provider.method()).rejects.toThrow("Exact error message expected");

		// ‚úÖ CORRECT: Use Error class
		await expect(provider.method()).rejects.toThrow(Error);
	});

	test("should handle provider-specific errors correctly", async () => {
		// ‚úÖ REAL-WORLD EXAMPLE: Match actual error messages
		const genericErrorMessage = "Network Error";
		mockApiCall.mockRejectedValue(new Error(genericErrorMessage));

		// ‚úÖ CORRECT: Test actual behavior, not idealized behavior
		await expect(provider.generate(MOCK_PROMPT)).rejects.toThrow(
			"Provider LLM API call failed (Model: model-name): Network Error"
		);

		expect(llmUtils.logInteraction).toHaveBeenCalledWith(MOCK_PROMPT, expect.any(Error));
	});

	test("should verify error details separately when complex", async () => {
		mockFunction.mockRejectedValue(new Error("API Error"));

		try {
			await provider.method();
			fail("Should have thrown an error");
		} catch (error) {
			// ‚úÖ CORRECT: Detailed verification after catch
			expect(error).toBeInstanceOf(Error);
			expect(error.message).toContain("API Error");
			expect(error.message).toMatch(/API.*Error/);
		}
	});
});
```

### ‚ùå INCORRECT Error Testing Anti-Patterns

```typescript
// ‚ùå BAD: rejects.toThrow() with asymmetric matchers
await expect(method()).rejects.toThrow(
	expect.stringContaining("message") // DOES NOT WORK
);

// ‚ùå BAD: Complex matchers with rejects.toThrow()
await expect(method()).rejects.toThrow(
	expect.objectContaining({ message: "error" }) // WILL FAIL
);

// ‚ùå BAD: Testing idealized behavior instead of actual behavior
await expect(provider.generate()).rejects.toThrow(
	"Invalid response structure from API" // If provider doesn't actually validate this
);
```

### üìã toThrow() and rejects.toThrow() API Reference

**ACCEPTS:**

-   ‚úÖ String (exact match): `"Exact error message"`
-   ‚úÖ RegExp (pattern match): `/API.*Error/`
-   ‚úÖ Error Class: `Error`, `TypeError`, etc.
-   ‚úÖ Error Instance: `new Error("message")`

**DOES NOT ACCEPT:**

-   ‚ùå `expect.stringContaining()`
-   ‚ùå `expect.objectContaining()`
-   ‚ùå `expect.arrayContaining()`
-   ‚ùå Any asymmetric matchers

---

## üö® 9. Real-World Error Scenarios (LEARNED FROM DEBUGGING)

### ‚úÖ Test Actual Behavior, Not Idealized Behavior

**CRITICAL LESSON:** Always test what the code actually does, not what you think it should do.

```typescript
// ‚úÖ CORRECT: Test actual GeminiProvider behavior
test("should handle malformed response correctly", async () => {
	// Mock actual malformed response
	mockGenerateContent.mockResolvedValue({});

	const provider = new GeminiProvider();

	// ‚úÖ Test actual error message generated by the provider
	await expect(provider.generate(MOCK_PROMPT, { useCache: true })).rejects.toThrow(
		"Gemini LLM API call failed (Model: gemini-pro): Cannot read properties of undefined (reading 'text')"
	);
});

// ‚úÖ CORRECT: Some providers don't validate undefined responses
test("should handle undefined response from API", async () => {
	mockGenerateContent.mockResolvedValue({
		response: { text: () => undefined },
	});

	const provider = new GeminiProvider();
	const response = await provider.generate(MOCK_PROMPT, { useCache: true });

	// ‚úÖ Test actual behavior: provider returns undefined
	expect(response).toBeUndefined();
	expect(llmUtils.logInteraction).toHaveBeenCalledWith(MOCK_PROMPT, undefined);
});
```

### ‚ùå INCORRECT: Testing Idealized Behavior

```typescript
// ‚ùå BAD: Testing behavior that doesn't exist
test("should validate API response", async () => {
	mockApiCall.mockResolvedValue({ invalid: "response" });

	// ‚ùå This will fail if the provider doesn't actually validate responses
	await expect(provider.generate()).rejects.toThrow("Invalid response structure from API");
});
```

---

## üîç 10. Cache Testing Patterns (PROVEN)

### ‚úÖ CORRECT Cache Testing

```typescript
describe("Caching Behavior", () => {
	test("should handle cache miss scenario", async () => {
		(llmUtils.loadCache as jest.Mock).mockResolvedValue({}); // Empty cache

		const result = await provider.generate(MOCK_PROMPT, { useCache: true });

		// ‚úÖ Verify cache operations in correct order
		expect(llmUtils.hashPrompt).toHaveBeenCalledWith(MOCK_PROMPT);
		expect(llmUtils.loadCache).toHaveBeenCalledTimes(2); // Load + reload before save
		expect(mockApiCall).toHaveBeenCalledTimes(1);
		expect(llmUtils.saveCache).toHaveBeenCalledWith({ [MOCK_HASH]: MOCK_RESPONSE });
		expect(llmUtils.logInteraction).toHaveBeenCalledWith(MOCK_PROMPT, MOCK_RESPONSE);

		expect(result).toBe(MOCK_RESPONSE);
	});

	test("should handle cache hit scenario", async () => {
		(llmUtils.loadCache as jest.Mock).mockResolvedValue({ [MOCK_HASH]: MOCK_RESPONSE });

		const result = await provider.generate(MOCK_PROMPT, { useCache: true });

		// ‚úÖ Verify cache short-circuit
		expect(llmUtils.loadCache).toHaveBeenCalledTimes(1);
		expect(mockApiCall).not.toHaveBeenCalled();
		expect(llmUtils.saveCache).not.toHaveBeenCalled();
		expect(llmUtils.logInteraction).toHaveBeenCalledWith(MOCK_PROMPT, `[CACHE HIT] ${MOCK_RESPONSE}`);

		expect(result).toBe(MOCK_RESPONSE);
	});

	test("should not use cache when useCache is false", async () => {
		const result = await provider.generate(MOCK_PROMPT, { useCache: false });

		// ‚úÖ Verify cache bypass
		expect(llmUtils.hashPrompt).toHaveBeenCalledWith(MOCK_PROMPT);
		expect(llmUtils.loadCache).not.toHaveBeenCalled();
		expect(mockApiCall).toHaveBeenCalledTimes(1);
		expect(llmUtils.saveCache).not.toHaveBeenCalled();
		expect(llmUtils.logInteraction).toHaveBeenCalledWith(MOCK_PROMPT, MOCK_RESPONSE);

		expect(result).toBe(MOCK_RESPONSE);
	});
});
```

---

## üìä 11. Coverage Requirements

### ‚úÖ MANDATORY Test Coverage

-   **Constructor scenarios**: Valid initialization, missing dependencies
-   **Happy path**: All primary functionality with expected inputs
-   **Error scenarios**: API failures, invalid responses, network issues
-   **Edge cases**: Empty inputs, null values, boundary conditions
-   **Configuration variants**: Different options, environment variables
-   **Cache behavior**: Hit, miss, disabled scenarios
-   **Async patterns**: Promise resolution, rejection, timeout handling
-   **Real-world malformed responses**: Test actual provider behavior

---

## üö´ 12. Anti-Patterns to Avoid (UPDATED)

### ‚ùå CRITICAL Violations

```typescript
// ‚ùå jest.resetModules() - CRITICAL ANTI-PATTERN
beforeEach(() => {
	jest.resetModules(); // NEVER USE - causes performance issues and state problems
});

// ‚ùå Mock hoisting violations
const mockVariable = complexInitialization();
jest.mock("module", () => mockVariable); // Can cause hoisting errors

// ‚ùå Mixed mock clearing strategies
beforeEach(() => {
	mockFunction.mockReset();
	jest.clearAllMocks(); // REDUNDANT and potentially harmful
});

// ‚ùå Environment pollution
test("env test", () => {
	process.env.KEY = "value"; // No restoration
});

// ‚ùå Incomplete mocking allowing real code execution
jest.mock("module", () => ({
	...jest.requireActual("module"), // DANGEROUS partial mock
	specificFunction: jest.fn(),
}));

// ‚ùå Testing idealized instead of actual behavior
await expect(provider.method()).rejects.toThrow(
	"Perfect validation message" // If provider doesn't actually generate this
);

// ‚ùå Missing async handling
test("async test", () => {
	provider.asyncMethod(); // Missing await
	expect(result).toBe(expected); // Will fail
});

// ‚ùå Using asymmetric matchers with toThrow
await expect(method()).rejects.toThrow(
	expect.stringContaining("error") // WILL FAIL
);
```

---

## üîç 13. Common Test Failure Patterns & Debugging (REAL-WORLD)

### Mock Hoisting Errors

**SYMPTOM:** `ReferenceError: Cannot access 'mockVariable' before initialization`  
**CAUSE:** Using variables in `jest.mock()` callback that aren't properly hoisted  
**SOLUTION:** Follow the proven patterns from Section 2

```typescript
// ‚úÖ SOLUTION: Define everything needed inside jest.mock()
jest.mock("module", () => {
	const mockInstance = { method: jest.fn() };
	const constructorMock = jest.fn().mockImplementation(() => mockInstance);
	return constructorMock;
});
```

### Failed rejects.toThrow() Tests

**SYMPTOM:** Test fails with "Expected asymmetric matcher" error  
**CAUSE:** Using `expect.stringContaining()` with `rejects.toThrow()`  
**SOLUTION:** Use regex patterns or exact strings

**SYMPTOM:** Error message doesn't match expected pattern  
**SOLUTION:** Debug actual error messages:

```typescript
test("debug error messages", async () => {
	try {
		await provider.method();
		fail("Should have thrown");
	} catch (error) {
		console.log("ACTUAL ERROR:", error.message); // Debug actual message
		// Then create appropriate test expectation
		expect(error.message).toMatch(/actual.*pattern/);
	}
});
```

### Provider Behavior Mismatches

**SYMPTOM:** Tests expect specific validation errors but get generic JavaScript errors  
**SOLUTION:** Test actual provider behavior, not idealized behavior

```typescript
// ‚úÖ CORRECT: Test what actually happens
test("should handle malformed response", async () => {
	mockApiCall.mockResolvedValue({});

	// Test the actual error that gets thrown
	await expect(provider.generate()).rejects.toThrow("Cannot read properties of undefined (reading 'property')");
});
```

---

## üìã LLM Evaluation Checklist (UPDATED)

When evaluating or writing tests, verify:

1. **Mock Strategy**: Single `jest.clearAllMocks()` pattern? ‚úÖ/‚ùå
2. **TypeScript**: Proper mock typing throughout? ‚úÖ/‚ùå
3. **Environment**: Complete env var backup/restore? ‚úÖ/‚ùå
4. **Console**: Suppressed but verifiable console output? ‚úÖ/‚ùå
5. **Coverage**: All required scenarios covered? ‚úÖ/‚ùå
6. **Error Handling**: Tests actual provider behavior? ‚úÖ/‚ùå
7. **Async**: Proper async/await usage? ‚úÖ/‚ùå
8. **Assertions**: Complete verification in correct order? ‚úÖ/‚ùå
9. **Anti-patterns**: No forbidden patterns present? ‚úÖ/‚ùå
10. **ESM**: `__esModule: true` in module mocks? ‚úÖ/‚ùå
11. **Error Testing**: Uses correct patterns with `rejects.toThrow()`? ‚úÖ/‚ùå
12. **Jest API**: Avoids asymmetric matchers with `toThrow()`? ‚úÖ/‚ùå
13. **jest.resetModules()**: Avoids use of `jest.resetModules()`? ‚úÖ/‚ùå
14. **Mock Hoisting**: Follows proven hoisting patterns? ‚úÖ/‚ùå

**COMPLIANCE SCORE**: \_\_\_/14 (Must be 14/14 for approval)

---

## üìù Standard Test List for LlmProvider (COMPREHENSIVE)

This section defines the exact test cases that must be implemented for any `LlmProvider`, based on proven successful implementations.

### Constructor Tests (MANDATORY)

```typescript
describe("Constructor", () => {
	test("should throw an error if API_KEY is not set", () => {
		delete process.env.PROVIDER_API_KEY;
		expect(() => new ProviderClass()).toThrow("PROVIDER_API_KEY environment variable is not set.");
	});

	test("should not throw an error if API_KEY is set", () => {
		process.env.PROVIDER_API_KEY = MOCK_API_KEY;
		expect(() => new ProviderClass()).not.toThrow();
		expect(MockedConstructor).toHaveBeenCalledWith({ apiKey: MOCK_API_KEY });
	});
});
```

### Generate Method Tests (COMPREHENSIVE)

#### Cache Handling (MANDATORY - All 3 scenarios)

```typescript
test("successful API call with no cache hit (useCache=true, cache empty)", async () => {
	const provider = new ProviderClass();
	const options: LlmOptions = { useCache: true };
	const response = await provider.generate(MOCK_PROMPT, options);

	// 1. Input validation
	expect(llmUtils.hashPrompt).toHaveBeenCalledWith(MOCK_PROMPT);

	// 2. Cache operations
	expect(llmUtils.loadCache).toHaveBeenCalledTimes(2);

	// 3. API calls
	expect(MockedConstructor).toHaveBeenCalledWith({ apiKey: MOCK_API_KEY });
	expect(mockApiMethod).toHaveBeenCalledWith(expectedStructure);

	// 4. Side effects
	expect(llmUtils.saveCache).toHaveBeenCalledWith({ [MOCK_PROMPT_HASH]: MOCK_RESPONSE_TEXT });
	expect(llmUtils.logInteraction).toHaveBeenCalledWith(MOCK_PROMPT, MOCK_RESPONSE_TEXT);

	// 5. Return value
	expect(response).toBe(MOCK_RESPONSE_TEXT);
});

test("successful API call when useCache is false", async () => {
	const provider = new ProviderClass();
	const options: LlmOptions = { useCache: false };
	await provider.generate(MOCK_PROMPT, options);

	expect(llmUtils.hashPrompt).toHaveBeenCalledWith(MOCK_PROMPT);
	expect(llmUtils.loadCache).not.toHaveBeenCalled();
	expect(mockApiMethod).toHaveBeenCalledTimes(1);
	expect(llmUtils.saveCache).not.toHaveBeenCalled();
	expect(llmUtils.logInteraction).toHaveBeenCalledWith(MOCK_PROMPT, MOCK_RESPONSE_TEXT);
});

test("cache hit scenario (useCache=true)", async () => {
	(llmUtils.loadCache as jest.Mock).mockResolvedValue({ [MOCK_PROMPT_HASH]: MOCK_RESPONSE_TEXT });

	const provider = new ProviderClass();
	const options: LlmOptions = { useCache: true };
	const response = await provider.generate(MOCK_PROMPT, options);

	expect(llmUtils.loadCache).toHaveBeenCalledTimes(1);
	expect(mockApiMethod).not.toHaveBeenCalled();
	expect(llmUtils.saveCache).not.toHaveBeenCalled();
	expect(llmUtils.logInteraction).toHaveBeenCalledWith(MOCK_PROMPT, `[CACHE HIT] ${MOCK_RESPONSE_TEXT}`);
	expect(response).toBe(MOCK_RESPONSE_TEXT);
});
```

#### Model Configuration (MANDATORY - All 3 scenarios)

```typescript
test("should use custom model name when provided", async () => {
	const customModelName = "custom-model";
	const provider = new ProviderClass();
	const options: LlmOptions = { useCache: true, modelName: customModelName };
	await provider.generate(MOCK_PROMPT, options);

	expect(mockApiMethod).toHaveBeenCalledWith(expect.objectContaining({ model: customModelName }));
});

test("should use environment model when available", async () => {
	process.env.PROVIDER_MODEL = "env-model";
	const provider = new ProviderClass();
	const options: LlmOptions = { useCache: true };
	await provider.generate(MOCK_PROMPT, options);

	expect(mockApiMethod).toHaveBeenCalledWith(expect.objectContaining({ model: "env-model" }));
});

test("should fallback to default model", async () => {
	delete process.env.PROVIDER_MODEL;
	const provider = new ProviderClass();
	const options: LlmOptions = { useCache: true };
	await provider.generate(MOCK_PROMPT, options);

	expect(mockApiMethod).toHaveBeenCalledWith(expect.objectContaining({ model: "default-model" }));
});
```

#### Error Handling (MANDATORY - Test actual behavior)

```typescript
test("should handle generic API errors", async () => {
	const errorMessage = "Generic API Error";
	mockApiMethod.mockRejectedValue(new Error(errorMessage));

	const provider = new ProviderClass();

	// ‚úÖ Test actual error format produced by provider
	await expect(provider.generate(MOCK_PROMPT, { useCache: true })).rejects.toThrow(
		"Provider LLM API call failed (Model: default-model): Generic API Error"
	);

	expect(llmUtils.logInteraction).toHaveBeenCalledWith(MOCK_PROMPT, expect.any(Error));
});

test("should handle provider-specific errors", async () => {
	// Test provider-specific error structures
	const specificError = new ProviderSpecificError("Specific message", 401);
	mockApiMethod.mockRejectedValue(specificError);

	await expect(provider.generate(MOCK_PROMPT, { useCache: true })).rejects.toThrow(
		/Provider.*API call failed.*401.*Specific message/
	);
});

test("should handle malformed API responses", async () => {
	// ‚úÖ CRITICAL: Test actual malformed response handling
	mockApiMethod.mockResolvedValue({ invalidStructure: true });

	const provider = new ProviderClass();

	// ‚úÖ Test what actually happens, not idealized validation
	await expect(provider.generate(MOCK_PROMPT, { useCache: true }))
		.rejects.toThrow
		// Use actual error message generated by provider
		();
});
```

---

## üéØ Quick Reference Commands (UPDATED)

```typescript
// Standard beforeEach pattern (PROVEN)
beforeEach(() => {
	process.env = { ...OLD_ENV };
	jest.clearAllMocks();

	// Set up default mock implementations
	(mockFunction as jest.Mock).mockReturnValue(defaultValue);
});

// Environment backup pattern (PROVEN)
const OLD_ENV = process.env;
beforeEach(() => {
	process.env = { ...OLD_ENV };
});
afterAll(() => {
	process.env = OLD_ENV;
});

// Console suppression pattern (PROVEN)
let consoleSpy: jest.SpyInstance;
beforeAll(() => {
	consoleSpy = jest.spyOn(console, "log").mockImplementation(() => {});
});
afterAll(() => {
	consoleSpy.mockRestore();
});

// TypeScript mock typing (PROVEN)
const MockedClass = OriginalClass as jest.MockedClass<typeof OriginalClass>;
(utils.function as jest.Mock).mockReturnValue(value);

// LLM Provider mock pattern (PROVEN - use as template)
const mockApiMethod = jest.fn();
const mockInstance = { api: { method: mockApiMethod } };
jest.mock("sdk", () => jest.fn().mockImplementation(() => mockInstance));
const MockedConstructor = SDK as jest.MockedClass<typeof SDK>;

// ‚úÖ CORRECT Error Testing Patterns
await expect(asyncFunction()).rejects.toThrow(/error.*pattern/);
await expect(asyncFunction()).rejects.toThrow("Exact error message");
await expect(asyncFunction()).rejects.toThrow(SpecificErrorClass);

// ‚ùå INCORRECT - DO NOT USE
await expect(asyncFunction()).rejects.toThrow(expect.stringContaining("error"));
jest.resetModules(); // NEVER USE THIS
```

---

## üö® CRITICAL CHANGE LOG

### Version 2.0 Updates (MAJOR):

-   **ADDED**: Comprehensive mock hoisting section with real-world debugging insights
-   **ADDED**: Proven LLM Provider mock patterns from successful implementations
-   **ADDED**: Real-world error scenarios and debugging based on actual test failures
-   **ADDED**: "Test actual behavior, not idealized behavior" principle
-   **UPDATED**: All examples to reflect patterns from successful chatgpt-provider.test.ts
-   **EXPANDED**: Error testing patterns with specific provider examples
-   **CONSOLIDATED**: All knowledge from debugging sessions into unified guide
-   **VERIFIED**: All patterns against working test implementations

### Version 1.3 Updates:

-   **ADDED**: `jest.resetModules()` as a critical anti-pattern
-   **UPDATED**: LLM Evaluation Checklist to 13 points
-   **ADDED**: Mock hoisting violations to anti-patterns

### Version 1.2 Updates:

-   **FIXED**: All incorrect `expect.stringContaining()` usage with `toThrow()`
-   **ADDED**: Jest API Limitations and Error Testing Patterns section
-   **VERIFIED**: All code examples tested against actual Jest behavior

---
